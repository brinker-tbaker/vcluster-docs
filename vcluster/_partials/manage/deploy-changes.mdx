import Flow, { Step } from "@site/src/components/Flow";
import Tabs from '@theme/Tabs'
import TabItem from '@theme/TabItem'

<Tabs
  groupId="get-started"
  defaultValue="cli"
  values={[
	{ label: "vCluster CLI", value: "cli" },
    { label: 'Helm', value: 'helm', },
    { label: 'Terraform', value: 'terraform', },
    { label: 'Argo CD', value: 'argo', },
    { label: 'Cluster API', value: 'cluster-api', },
  ]
}>
<TabItem value="cli">

:::info vCluster CLI Version
To keep the same version of your vCluster, your CLI needs to be the same version as your virtual cluster.
:::

```bash
vcluster create --upgrade $VCLUSTER_NAME -n $VCLUSTER_NAMESPACE -f vcluster.yaml
```

Replace:

- `$VCLUSTER_NAME` with the name of the vCluster instance to update.
- `$VCLUSTER_NAMESPACE` with the namespace where the vCluster instance is deployed.



</TabItem>
<TabItem value="helm">

```bash
helm upgrade --install $VCLUSTER_NAME vcluster \
  --values vcluster.yaml \
  --repo https://charts.loft.sh \
  --namespace $VCLUSTER_NAMESPACE \
  --repository-config=''
```

Replace:

- `$VCLUSTER_NAME` with the name of the vCluster instance to update.
- `$VCLUSTER_NAMESPACE` with the namespace where the vCluster instance is deployed.

</TabItem>
<TabItem value="terraform">

<Flow>
  The steps assume that you have the terraform file that you initially deployed your terraform resource from. 

  <Step> 

    Generate a new plan with your updated `vcluster.yaml`.

    ```bash
    terraform plan
    ```
  
    Verify that the provider can access your cluster and that the proposed changes are correct.
  
  </Step>
  <Step>

    Apply your new changes.

    ```bash
    terraform apply
    ```
    
  </Step>
</Flow>

</TabItem>
<TabItem value="argo">

<Flow>
  <Step>
  
    Commit and push your updated `vcluster.yaml` to your configured ArgoCD repository.
  
  </Step>
  <Step>

    Synchronize your ArgoCD repository with your configured cluster.
    
  </Step>
</Flow>

</TabItem>
<TabItem value="cluster-api">

Apply Cluster API changes by regenerating the CAPI cluster custom resource using `clusterctl`.

```bash
export CLUSTER_NAME=VCLUSTER_NAME
export CLUSTER_NAMESPACE=VCLUSTER_NAMESPACE
export KUBERNETES_VERSION=1.30.2
export HELM_VALUES=$(cat vcluster.yaml)

clusterctl generate cluster ${CLUSTER_NAME} \
    --infrastructure vcluster \
    --kubernetes-version ${KUBERNETES_VERSION} \
    --target-namespace ${CLUSTER_NAMESPACE} | kubectl apply -f -
```

Replace:

- `VCLUSTER_NAME` with the name of the vCluster instance to update.
- `VCLUSTER_NAMESPACE` with the namespace where the vCluster instance is deployed.

After the changes have been applied, wait for the vCluster custom resource to report a ready status:

```bash
kubectl wait --for=condition=ready vcluster -n $CLUSTER_NAMESPACE $CLUSTER_NAME --timeout=300s
```

</TabItem>
</Tabs>
